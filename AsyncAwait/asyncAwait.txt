An async function is a function declared with the async keyword. Async functions are instances of the AsyncFunction constructor, and the await keyword is permitted within them. The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.

function resolveAfter2Seconds() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('resolved');
    }, 2000);
  });
}

async function asyncCall() {
  console.log('calling');
  const result = await resolveAfter2Seconds();
  console.log(result);
  // expected output: "resolved"
}

var p1 = asyncCall(); // p1 --> Promise

Return value:

  - A Promise which will be resolved with the value returned by the async function, or rejected with an exception thrown from, or uncaught within, the async function.
  - Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.

  async function notPromise() {
     return "Franco";
  }

  var p2 = notPromise() // p2 --> Promise fulfilled === return Promise.resolve(1)

Mostrar que no se queda "trabado" en el await:

console.log("Inicio")
asyncCall()
console.log("Fin")

Equivalente con lo que vimos de Promesas:

resolveAfter2Seconds().then(function(value) {
  console.log(value);
})

Async functions can contain zero or more await expressions. Await expressions suspend progress through an async function, yielding control and subsequently resuming progress only when an awaited promise-based asynchronous operation is either fulfilled or rejected.

The purpose of async/await is to simplify the syntax necessary to consume promise-based APIs. The behavior of async/await is similar to combining generators and promises.


Otro ejemplo:

async function showInstructors() {
  const instructor1 = await new Promise((resolve) => setTimeout(() => resolve('Franco')));
  console.log(instructor1);
  const instructor2 = await new Promise((resolve) => setTimeout(() => resolve('Toni')));
  console.log(instructor2);
}

function henryAwait() {
  console.log("¿Quienes son los intstructores de Henry?");
  showInstructors();
  console.log("Gracias vuelvan pronto");
}

henryAwait()
console.log("FIN");

Flow:

 1) Se ejecuta henryAwait, console.log, luego showInstructors(), ingresa al body de la función y ejecuta de forma sincrónica la primer linea y ahí al encontrar la palabra await devuelve el control a la función que invocó a showInstructors
 2) Por eso luego muestra el "Gracias ..." y contiua ejecutando ... "FIN"
 3) Pasado un tiempo, cuando se resuelve/rechaza la promesa y estando el stack de ejecución libre obtiene nuevamente el control y muestra al instructor (Mismo sucede con el otro a)
